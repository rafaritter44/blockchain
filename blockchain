type bloco = {hash:string, hashanterior:string, dados:string};

fun gethash ({hash=h, hashanterior=_, dados=_} : bloco) = h;

fun gethashanterior ({hash=_, hashanterior=ha, dados=_} : bloco) = ha;

fun getdados ({hash=_, hashanterior=_, dados=d} : bloco) = d;

type cadeia = bloco list;

fun criabloco (hash:string, dados:string, []) = 
let
	val hashanterior = ""
in
	{hash, hashanterior, dados}:bloco
end
  | criabloco (hash:string, dados:string, c::cs:cadeia) = 
let
	val hashanterior = gethash c
in
	{hash, hashanterior, dados}:bloco
end;

fun add (b:bloco, []) = [b]
  | add (b:bloco, c:cadeia) = b::c;

fun gerahash (hashanterior, dados, nonce) = hashanterior ^ dados;

fun isvalido [] = true
  | isvalido (c::[]) =
let
	val hashanterior = gethashanterior c
	val hash = gethash c
	val hashanteriorreal = ""
	val hashreal = gerahash (hashanteriorreal, getdados c)
in
	hashanterior = hashanteriorreal
	andalso hash = hashreal
end
  | isvalido (c::ca::cs) =
let
	val hashanterior = gethashanterior c
	val hash = gethash c
	val hashanteriorreal = gethash ca
	val hashreal = gerahash (hashanteriorreal, getdados c)
in
	hashanterior = hashanteriorreal
	andalso hash = hashreal
	andalso isvalido (ca::cs)
end;

fun blocotojson b =
let
	val hash = gethash b
	val hashanterior = gethashanterior b
	val dados = getdados b
in
	"{\"hash\": \"" ^ hash ^
	"\", \"hashanterior\": \"" ^ hashanterior ^
	"\", \"dados\": \"" ^ dados ^ "\"}"
end;

fun tojson c = "[" ^ String.concatWith "," (map blocotojson c) ^ "]";

fun add ([], n) = [n]
  | add (x::xs, n) = x::add (xs, n);

fun tovalor (#":"::(#" "::(#"\""::xs)), s) = tovalor (xs, "")
  | tovalor (#"\""::(#","::xs), s) = {valor = s, resto = xs}
  | tovalor (#"\""::(#"}"::xs), s) = {valor = s, resto = xs}
  | tovalor (x::xs, s) = tovalor (xs, s ^ Char.toString x)
  | tovalor ([], s) = {valor = "", resto = []};

fun tobloco (#"{"::xs, ys) = tobloco (xs, [])
  | tobloco (#"}"::xs, ys) = {bloco = add (ys, #"}"), resto = xs}
  | tobloco (x::xs, ys) = tobloco (xs, add (ys, x))
  | tobloco ([], ys) = {bloco = [], resto = []};

fun tocadeia ([], ys) = ys
  | tocadeia (xs, ys) = if #bloco (tobloco (xs, [])) = [] then ys else
let
	val blocoeresto = tobloco (xs, [])
	val b = #bloco blocoeresto
	val r = #resto blocoeresto
	val hasheresto = tovalor (b, "")
	val hash = #valor hasheresto
	val hashanterioreresto = tovalor (#resto hasheresto, "")
	val hashanterior = #valor hashanterioreresto
	val dadoseresto = tovalor (#resto hashanterioreresto, "")
	val dados = #valor dadoseresto
	val bloco = {hash, hashanterior, dados};
	val cadeia = add (ys, bloco);
in
	tocadeia (r, cadeia)
end;

fun fromjson s = tocadeia (explode s, []);

(* fun escrever (nomearquivo, conteudo) =
let
	val arquivo = (TextIO.openOut nomearquivo
	handle _
	=> (TextIO.output (TextIO.stdErr,nomearquivo ^ " not found. This sucks.\n");
	OS.Process.exit OS.Process.failure))
	val _ = TextIO.output (arquivo, conteudo)
in
	TextIO.closeOut arquivo
end;

fun ler nomearquivo =
let
	val arquivo = (TextIO.openIn nomearquivo
	handle _
	=> (TextIO.output (TextIO.stdErr,nomearquivo ^ " not found. This sucks.\n");
	OS.Process.exit OS.Process.failure))
	val conteudo = TextIO.inputAll arquivo
	val _ = TextIO.closeIn arquivo
in
	conteudo
end; *)

fun dificuldade 0 = ""
  | dificuldade n = "0" ^ prefixo (n - 1);

fun mineraraux (dificuldade, hashanterior, dados, nonce) =
let
	val hash = gerahash (hashanterior, dados, nonce)
in
	if dificuldade = substring (hash, 0, size dificuldade)
		then hash
	else
		mineraraux (dificuldade, hashanterior, dados, nonce + 1)
end;

fun minerar (dif, hashanterior, dados) =
let
	val dificuldade = dificuldade dif;
in
	mineraraux (dificuldade, hashanterior, dados, 0)
end;
	